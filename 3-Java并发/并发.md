# 概念

## 同步和异步

同步和异步关注的是消息通信机制，由被调用的方法返回的信息的机制。

### 同步

同步，就是在发出一个调用时，在没有得到结果之前，该调用就不返回。但是一旦调用返回，就得到返回值了。

### 异步

异步则是相反，调用在发出之后，这个调用就直接返回了，所以没有返回结果。换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。而是在调用发出后，被调用者通过状态、通知来通知调用者，或通过回调函数处理这个调用。

## 串行和并行

### 串行

任务一个接一个的被完成，同时只能执行一个任务，任务的执行是于先后顺序的。

类似于

### 并行

任务同时执行。没有先后顺序，同时开始，如果任务量相同，也近乎同时完成。

类似于跑步比赛。

## 阻塞和非阻塞

阻塞和非阻塞关注的是程序在等待调用结果时的状态：方法调用者的状态。

### 阻塞

阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。

### 非阻塞

非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。

# 并发基础

## Daemon

Daemon是是守护线程的意思，当所有的非守护线程结束的时候，整个进程结束，也就是说守护线程是为非守护线程服务的。

此外main方法是非守护线程，也属于被服务对象。

调用方法是：

```java
public static void main(String[] args) {
    Thread thread = new Thread(new MyRunnable());
    thread.setDaemon(true);
}
```

## yield

yield方法是Thread的静态方法，表示在线程调度上让步，通常在一个线程的主要任务完成之后使用这个方法。该方法只是对线程调度器的一个建议，而且也只是建议具有相同优先级的其它线程可以运行。

```java
public void run() {
    Thread.yield();
}
```

## sleep

Thread.sleep(millisec) 方法会休眠当前正在执行的线程，millisec 单位为毫秒。

sleep() 可能会抛出 InterruptedException，因为异常不能跨线程传播回 main() 中，因此必须在本地进行处理。线程中抛出的其它异常也同样需要在本地进行处理。

```java
public void run() {
    try {
        Thread.sleep(3000);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
}
```

## wait、notify

wait和notify它们是Object的方法。

这一组信号一般和synchronized关键字组合使用。

调用wait方法时，线程进入等待状态，并且会释放synchronized的锁。

一个线程使用了wait的方法之后，重新苏醒条件是：其他的线程对这个锁使用了notify方法，并且这个锁没有被占用。

得到了notify信号之后，线程从执行wait的地方恢复执行。

添加参数的wait和notify就是表示有时间的延迟的wait和notify。

### wait() 和 sleep() 的区别 

wait() 是 Object 的方法，而 sleep() 是 Thread 的静态方法。

wait() 会释放锁，sleep() 不会。

