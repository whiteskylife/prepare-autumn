# 概念

## 同步和异步

同步和异步关注的是消息通信机制，由被调用的方法返回的信息的机制。

### 同步

同步，就是在发出一个调用时，在没有得到结果之前，该调用就不返回。但是一旦调用返回，就得到返回值了。

### 异步

异步则是相反，调用在发出之后，这个调用就直接返回了，所以没有返回结果。换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。而是在调用发出后，被调用者通过状态、通知来通知调用者，或通过回调函数处理这个调用。

## 串行和并行

### 串行

任务一个接一个的被完成，同时只能执行一个任务，任务的执行是于先后顺序的。

类似于

### 并行

任务同时执行。没有先后顺序，同时开始，如果任务量相同，也近乎同时完成。

类似于跑步比赛。

## 阻塞和非阻塞

阻塞和非阻塞关注的是程序在等待调用结果时的状态：方法调用者的状态。

### 阻塞

阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。

### 非阻塞

非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。

# 并发基础

## Daemon

Daemon是是守护线程的意思，当所有的非守护线程结束的时候，整个进程结束，也就是说守护线程是为非守护线程服务的。

此外main方法是非守护线程，也属于被服务对象。

调用方法是：

```java
public static void main(String[] args) {
    Thread thread = new Thread(new MyRunnable());
    thread.setDaemon(true);
}
```

## yield

yield方法是Thread的静态方法，表示在线程调度上让步，通常在一个线程的主要任务完成之后使用这个方法。该方法只是对线程调度器的一个建议，而且也只是建议具有相同优先级的其它线程可以运行。

```java
public void run() {
    Thread.yield();
}
```

## sleep

Thread.sleep(millisec) 方法会休眠当前正在执行的线程，millisec 单位为毫秒。

sleep() 可能会抛出 InterruptedException，因为异常不能跨线程传播回 main() 中，因此必须在本地进行处理。线程中抛出的其它异常也同样需要在本地进行处理。

```java
public void run() {
    try {
        Thread.sleep(3000);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
}
```

## wait、notify

wait和notify它们是Object的方法。

这一组信号一般和synchronized关键字组合使用。

调用wait方法时，线程进入等待状态，并且会释放synchronized的锁。

一个线程使用了wait的方法之后，重新苏醒条件是：其他的线程对这个锁使用了notify方法，并且这个锁没有被占用。

得到了notify信号之后，线程从执行wait的地方恢复执行。

添加参数的wait和notify就是表示有时间的延迟的wait和notify。

### wait() 和 sleep() 的区别 

wait() 是 Object 的方法，而 sleep() 是 Thread 的静态方法。

wait() 会释放锁，sleep() 不会。

# 互斥同步

## Synchronized

### synchronized (X.class)

```java
package com.company;

import java.util.concurrent.*;

/**
 * 中建
 *
 * @author thisxzj
 * @date 2019 2019-08-11 14:27
 */


public class SynchronizedTest {
    public static void main(String[] args) {
        ExecutorService executorService = Executors.newCachedThreadPool();
        for (int i = 0; i < 3; i++) {
            executorService.execute(new MyRunnable());
        }
        executorService.shutdown();
    }
}

class MyRunnable implements Runnable {
    @Override
    public void run() {
        SynchronizedExample s = new SynchronizedExample();
        try {
            s.func();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}

class SynchronizedExample {
    public void func() throws InterruptedException {
        synchronized (SynchronizedExample.class) {
            for (int i = 0; i < 5; i++) {
                long threadId = Thread.currentThread().getId();
                System.out.println(threadId + " " + i + " ");
                if (threadId % 2 == 0) {
                    Thread.sleep(2);
                }
            }
        }
    }
}
```

结果

```Java
10 0 
10 1 
10 2 
10 3 
10 4 
12 0 
12 1 
12 2 
12 3 
12 4 
11 0 
11 1 
11 2 
11 3 
11 4 
```

如果将同步语句去掉

```java
package com.company;

import java.util.concurrent.*;

/**
 * 中建
 *
 * @author thisxzj
 * @date 2019 2019-08-11 14:27
 */


public class SynchronizedTest {
    public static void main(String[] args) {
        ExecutorService executorService = Executors.newCachedThreadPool();
        for (int i = 0; i < 3; i++) {
            executorService.execute(new MyRunnable());
        }
        executorService.shutdown();
    }
}

class MyRunnable implements Runnable {
    @Override
    public void run() {
        SynchronizedExample s = new SynchronizedExample();
        try {
            s.func();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}

class SynchronizedExample {
    public void func() throws InterruptedException {
        //使用this表示类的实例只能有一个执行这个代码块方法
//        synchronized (SynchronizedExample.class) {
        for (int i = 0; i < 5; i++) {
            long threadId = Thread.currentThread().getId();
            System.out.println(threadId + " " + i + " ");
            if (threadId % 2 == 0) {
                Thread.sleep(2);
            }
        }
//        }
    }
}
```

```java
11 0 
11 1 
11 2 
11 3 
11 4 
10 0 
12 0 
10 1 
12 1 
10 2 
12 2 
10 3 
12 3 
10 4 
12 4 
```

那么，明显结果会呈现没有顺序的执行。

### synchronized (this)

对于多个线程使用同一个实例而言，每次只能一个线程可以使用这个对象的代码块。

```java
import java.util.concurrent.*;

/**
 * @author thisxzj
 */

public class SynchronizedTest {
    public static void main(String[] args) {
        SynchronizedExample e = new SynchronizedExample();
        ExecutorService executorService = Executors.newCachedThreadPool();
        executorService.execute(e::func);
        executorService.execute(e::func);
    }
}

class SynchronizedExample {
    void func() {
        synchronized (this) {
            for (int i = 0; i < 10; i++) {
                System.out.print(i + " ");
                try {
                    if (i % 2 == 0) {
                        Thread.sleep(1);
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}

```

```java
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 
```

在上面这个例子中，线程池中的两个方法都会使用func这个方法，但是只能有一个线程能够进入代码块，另一个线程只能等待前一个线程结束。

```java
package com.company;

import java.util.concurrent.*;

/**
 * @author thisxzj
 */

public class SynchronizedTest {
    public static void main(String[] args) {
        SynchronizedExample e = new SynchronizedExample();
        ExecutorService executorService = Executors.newCachedThreadPool();
        executorService.execute(e::func);
        executorService.execute(e::func);
        executorService.shutdown();
    }
}

class SynchronizedExample {
    void func() {
//        synchronized (this) {
        for (int i = 0; i < 10; i++) {
            System.out.print(i + " ");
            try {
                if (i % 2 == 0) {
                    Thread.sleep(1);
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
//    }
}
```

```java
0 0 1 2 1 2 3 4 3 4 5 6 5 6 7 8 7 8 9 9 
```

在上面这个例子中，由于没有使用同步机制，所以明显可以看出，两个线程同时都在循环体中执行这个代码块。

### 方法签名

#### 实例方法

使用在实例方法签名上的synchronized关键字，和synchronized (this)一样，作用于实例。

```Java
class SynchronizedExample {
    void func() {
        synchronized (this) {
            //TODO
        }
    }

    synchronized void func() {
        //TODO
    }
}
```

也就是说以上的两个方法等价，两种方法等价的条件是第一种写法的第二行和第三行之间不能有语句，第五行和第六行之间也不能有语句。

#### 静态方法

```java
class SynchronizedExample {
    public void func() throws InterruptedException {
        synchronized (SynchronizedExample.class) {
            for (int i = 0; i < 5; i++) {
                long threadId = Thread.currentThread().getId();
                System.out.println(threadId + " " + i + " ");
                if (threadId % 2 == 0) {
                    Thread.sleep(2);
                }
            }
        }
    }

    static synchronized void func() throws InterruptedException {
        for (int i = 0; i < 5; i++) {
            long threadId = Thread.currentThread().getId();
            System.out.println(threadId + " " + i + " ");
            if (threadId % 2 == 0) {
                Thread.sleep(2);
            }
        }
    }
}
```

上面代码中，两个方法能够达到的同步效果是一致的，即，同时只能有一处进入这个代码块或者是方法。但是区别在于两个方法，一个是静态方法，一个是实例方法。也就是说，在使用的过程中有差异。