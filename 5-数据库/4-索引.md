```sql
mysql> desc building;
+---------------+------------------+------+-----+-------------------+-----------------------------+
| Field         | Type             | Null | Key | Default           | Extra                       |
+---------------+------------------+------+-----+-------------------+-----------------------------+
| id            | int(11) unsigned | NO   | PRI | NULL              | auto_increment              |
| is_deleted    | tinyint(4)       | NO   |     | 0                 |                             |
| create_at     | datetime         | YES  |     | CURRENT_TIMESTAMP |                             |
| update_at     | datetime         | NO   |     | CURRENT_TIMESTAMP | on update CURRENT_TIMESTAMP |
| building_name | varchar(64)      | NO   |     | NULL              |                             |
+---------------+------------------+------+-----+-------------------+-----------------------------+
5 rows in set (0.00 sec)

mysql> select * from building limit 10;
+----+------------+---------------------+---------------------+-----------------+
| id | is_deleted | create_at           | update_at           | building_name   |
+----+------------+---------------------+---------------------+-----------------+
|  7 |          0 | 2019-08-22 19:25:57 | 2019-08-22 19:26:29 | 汇文楼          |
|  8 |          0 | 2019-08-22 19:26:13 | 2019-08-23 13:41:14 | 3号楼           |
|  9 |          0 | 2019-08-22 19:26:25 | 2019-08-22 19:26:25 | 4号楼           |
| 10 |          0 | 2019-08-22 19:26:36 | 2019-08-22 19:26:36 | 农学楼          |
| 11 |          0 | 2019-08-22 19:26:43 | 2019-08-22 19:26:43 | 2号楼           |
| 12 |          0 | 2019-08-22 19:26:50 | 2019-08-22 19:26:50 | 1号楼           |
| 13 |          0 | 2019-08-22 19:26:56 | 2019-08-22 19:26:56 | 实验楼          |
| 14 |          0 | 2019-08-22 19:27:08 | 2019-08-22 19:27:08 | A-8             |
| 15 |          0 | 2019-08-22 19:27:39 | 2019-08-22 19:27:54 | 第一图书馆      |
| 16 |          0 | 2019-08-22 19:27:51 | 2019-08-22 19:27:51 | 第二图书馆      |
+----+------------+---------------------+---------------------+-----------------+
10 rows in set (0.00 sec)
```

# 索引的建立

## 单列索引

对于以上表，建立对于update_at的索引，语句是（这个两个语句有一样的效果）：

```sql
create index update_idnex on building(update_at);
```

```sql
alter table building add index update_idnex(update_at);
```

在`building(update_at)`中的列名`update_at`之后，可以加上长度量，如：

```sql
create index update_idnex on building(update_at(10));
```

如果是char、varchar类型，length可以小于字段的实际长度。

如果是BLOB和TEXT类型就必须指定一个合适的长度。

## 唯一索引

唯一索引，与普通索引类似，但是不同的是唯一索引要求所有的类的值是唯一的，允许有空值。

```sql
create unique index update_idnex on building(update_at);
```

```sql
alter table building add unique index update_idnex(update_at);
```

## 组合索引

一个表中含有多个索引不代表就是组合索引，通俗一点来讲，组合索引就是一个索引，包含了多个列。

创建一个组合索引的语句是：

```sql
create index indexName ON tableName(col_1, col_2);
```

## 全文索引

文本字段上如果建立的是普通索引，那么只有对文本的字段内容前面的字符进行索引，其字符大小根据建立索引时申明的大小来规定。

用于在一篇文章中，检索文本信息。

```sql
alter table tableName add fulltext index full_index_name(col_2);
```

在添加了全文索引之后，就可以用SELECT查询命令去检索那些包含着一个或多个给定单词的数据记录了。

例如：

```sql
select * from tableName where match(col_1, col_2) against(‘aa′, ‘bb′);
```

将`col_1`和`col_2`添加全文索引之后，那么这个语句将会把`col_1`和`col_2`中的所有包含`aa`和`bb`的项列出来。

## 主键索引

```sql
alter table tableName add primary key(col_1);
```

# 外键

如果一个字段 X 在表一中是主关键字，而在表二中不是主关键字，则字段 X 称为表二的外键。

## 外键的作用

- 级联删除：在删除主键表的时候，外键表同时删除
- 约束限制：当取值为No Action或者Restrict时，则当在主键表中删除对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除。（外键表约束主键表）
- Set Null：当取值为Set Null时，则当在主键表中删除对应记录时，首先检查该记录是否有对应外键，如果有则设置子表中该外键值为null。（一样是外键表约束主键表，不过这要求该外键允许取null）

## 外键的建立

```sql
ALTER TABLE '表名' ADD CONSTRAINT '外键名'
		FOREIGN KEY('外键字段') REFERENCES '关联表名'('关联字段'); --(去掉'')
```

`外键字段`与`关联字段`对应，并且在`关联表名`对应的表中应该是主键。



# 索引的删除

使用语句：

```sql
drop index indexName on tableName;
```

删除索引。

# 索引的优缺点

## 优点

- 单列索引：
  - 加快查询的速度。
- 唯一索引：
  - 加快查询速度。
  - 限制值的唯一性，可以为空。
- 全文索引：
  - 针对文本内容进行分词，加快查询速度。
- 组合索引
  - 多列组成的索引，效率高于单列索引的合并。
- 主键索引
  - 主键唯一性，加快查询速度，不能为空。

## 缺点

索引是占用空间的。

索引会影响update、insert、delete速度。

# 索引结构的分类

**索引是帮助mysql高效获取数据的数据结构。**

这是一个利用平衡搜索二叉树完成的一个索引的结构示意图。

![1](http://blog.codinglabs.org/uploads/pictures/theory-of-mysql-index/1.png)

大部分的数据库系统使用的都是`B Tree` 和`B+Tree` 。

## B-Tree

B-Tree：有序数组+平衡多叉树

B-Tree：平衡多路查找树

这就是一个M = 3阶的B - Tree:

![img](/Users/thisxzj/GitHub/prepare-autumn/photo/B-tree.png)



M阶的b树具有如下几个特征：
  - 根结点的儿子数为[ 2 , M ]
  - 除根结点以外的非叶子结点的儿子数为[  ⌈ M / 2 ⌉ - 1  ,  M  ]
  - （非叶子结点的关键字个数） = （儿子数） - 1
  - 所有叶子结点位于同一层
  - k个关键字把节点拆成k+1段，分别指向k+1个儿子，就是第四点说的关键字的数量和儿子的数量的关系。并且同时满足查找树的大小关系。

## B+Tree

B+Tree：有序数组链表+平衡多叉树

这是一个M = 3阶的 B + tree：

![B Plus tree](/Users/thisxzj/GitHub/prepare-autumn/photo/B+tree.png)

mysql最终选择的是B+树。

一个M阶的B+树的定义为：

- 根结点的儿子数为[ 2 , M ]
- 除根结点以外的非叶子结点的儿子数为[  ⌈ M / 2 ⌉  ,  M  ]
- （非叶子结点的关键字个数） = （儿子数） 
- 每个关键字不保存数据，只作为索引
- 所有叶子结点位于同一层
- 且叶子结点本身依关键字的大小自小而大顺序链接
- 所有的叶子结点中包含了全部元素的信息以及指向含这些元素记录的指针
- 每个父节点的元素都同时存在于子节点中，是子节点中的最大（或最小）元素



## B树和B+树的区别

### 区别

- 关键字的数量不同
  - 在 M 阶的B树中，最多只用 M - 1 个关键字。
  - 在 M 阶的B+树中，拥有 M 个关键字。
- 存储的位置不同
  - B树中，叶子结点和分支节点都存储数据信息。
  - B+树中，只有叶子结点存储数据信息。
- 分支节点的构造不同
  - B树中，存储关键字、关键字的数据信息和子节点的指针。
  - B+树中，存储关键字和存储子节点的指针。B+树的数据存储在叶子结点中。
- 查询方式不同
  - B 树在找到具体的数值以后，则结束。
  - B+ 树则需要通过索引找到叶子结点中的数据才结束，也就是说 B+ 树的搜索过程中走了一条从根结点到叶子结点的路径。

## 数据库的索引

B+树比B树更加适合做数据库的索引！

1. B+树的磁盘读写代价更低：

   B+树的内部节点并没有指向关键字具体信息的指针，因此其内部节点相对B树更小，如果把所有同一内部节点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量。也越多，一次性读入内存的需要查找的关键字也就越多，相对IO读写次数就降低了。

2. B+树的查询效率更加稳定：

   由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。

3. B+树的方便扫库：

   由于B+树的数据都存储在叶子结点中，分支结点均为索引，方便扫库，只需要扫一遍叶子结点即可，但是B树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫，所以B+树更加适合在区间查询的情况，所以通常B+树用于数据库索引。

B-树在提高了IO性能的同时并没有解决元素遍历的我效率低下的问题。正是为了解决这个问题，B+树应用而生。B+树只需要去遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作或者说效率太低。

# 利用索引优化查询

## 单列索引

在进行查询时，索引列不能是表达式的一部分，也不能是函数的参数，否则无法使用索引。

```sql
explain select * from building where building.id = 10;
```

以上语句就不能使用索引。

## 前缀索引

对于BLOB、TEXT和VARCHAR 类型的字段，必须使用前缀索引。只索引开始的部分字符，对于前缀长度的选取需要根据的索引选择性来确定。（不重复的索引值和记录总数的比值）选择性越高，查询效率也越高。最大值为 1 ，此时每个记录都有唯一的索引与其对应。

## 多列索引

在需要使用多个列作为条件进行查询时，使用多列索引比使用多个单列索引性能更好。

例如下 面的语句中，最好把 actor_id 和 file_id 设置为多列索引。

```sql
SELECT file_id, actor_ id FROM sakila.film_actor WHERE actor_id = 1 or film_id = 1;
```

## 索引列的顺序

让选择性最强的索引列放在前面。

## 聚簇索引

聚簇索引并不是一种索引类型，而是一种数据存储方式。

术语`聚簇`表示数据行和相邻的键值紧密地存储在一起。

InnoDB 的聚簇索引的数据行存放在B-Tree 的叶子页中。 

因为无法把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。

# 使用索引

需要创建索引的情况

1. 主键自动建立唯一索引
2. 频繁作为查询条件的字段应该创建索引
3. 查询中与其他表关联的字段，外键关系建立索引
4. 频繁更新的字段不适合建立索引，因为每次更新不单单是更新了记录还会更新索引
5. WHERE 条件里用不到的字段不创建索引
6. 单键/组合索引的选择问题，who?（在高并发下倾向创建组合索引）
7. 查询中排序的字段，排序的字段若通过索引去访问将大大提高排序速度
8. 查询中统计或者分组字段

不要创建索引的情况

1. 表记录太少
2. 经常增删改的表
3. 某个含有很多相同记录的字段

# 查询性能优化

使用explain查询优化结果

1. 这是一个走索引的查询语句

  ```sql
  explain select * from building where building.id = 10;
  ```
  
  ```sql
  +----+-------------+----------+------------+-------+---------------+---------+---------+-------+------+----------+-------+
  | id | select_type | table    | partitions | type  | possible_keys | key     | key_len | ref   | rows | filtered | Extra |
  +----+-------------+----------+------------+-------+---------------+---------+---------+-------+------+----------+-------+
  |  1 | SIMPLE      | building | NULL       | const | PRIMARY       | PRIMARY | 4       | const |    1 |   100.00 | NULL  |
  +----+-------------+----------+------------+-------+---------------+---------+---------+-------+------+----------+-------+
  ```
  
2. 这是一个不走索引的查询语句

3. ```sql
   explain select * from building where building.id + 1 = 10;
   ```

   ```sql
   +----+-------------+----------+------------+------+---------------+------+---------+------+------+----------+-------------+
   | id | select_type | table    | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |
   +----+-------------+----------+------------+------+---------------+------+---------+------+------+----------+-------------+
   |  1 | SIMPLE      | building | NULL       | ALL  | NULL          | NULL | NULL    | NULL |   18 |   100.00 | Using where |
   +----+-------------+----------+------------+------+---------------+------+---------+------+------+----------+-------------+
   ```

## select_type

1. simple：表示不需要union操作或者不包含子查询的简单select查询。有连接查询时，外层的查询为simple，且只有一个
2. primary：一个需要union操作或者含有子查询的select，位于最外层的单位查询的select_type即为primary。且只有一个
3. union：union连接的两个select查询，第一个查询是dervied派生表，除了第一个表外，第二个以后的表select_type都是union
4. dependent union：与union一样，出现在union 或union all语句中，但是这个查询要受到外部查询的影响
5. union result：包含union的结果集，在union和union all语句中,因为它不需要参与查询，所以id字段为null
6. subquery：除了from字句中包含的子查询外，其他地方出现的子查询都可能是subquery
7. dependent subquery：与dependent union类似，表示这个subquery的查询要受到外部表查询的影响
8. derived：from字句中出现的子查询，也叫做派生表，其他数据库中可能叫做内联视图或嵌套select

## type

依次从好到差：system，const，eq_ref，ref，fulltext，ref_or_null，unique_subquery，index_subquery，range，index_merge，index，all。

除了all之外，其他的都使用到了索引。除了index_merge之外，其他的type用到了一个索引。

其余：

1. system：表中只有一行数据或者是空表，且只能用于myisam和memory表。如果是Innodb引擎表，type列在这个情况通常都是all或者index
2. const：使用唯一索引或者主键，返回记录一定是1行记录的等值where条件时，通常type是const。其他数据库也叫做唯一索引扫描
3. eq_ref：出现在要连接过个表的查询计划中，驱动表只返回一行数据，且这行数据是第二个表的主键或者唯一索引，且必须为not null，唯一索引和主键是多列时，只有所有的列都用作比较时才会出现eq_ref
4. ref：不像eq_ref那样要求连接顺序，也没有主键和唯一索引的要求，只要使用相等条件检索时就可能出现，常见与辅助索引的等值查找。或者多列主键、唯一索引中，使用第一个列之外的列作为等值查找也会出现，总之，返回数据不唯一的等值查找就可能出现。
5. fulltext：全文索引检索，要注意，全文索引的优先级很高，若全文索引和普通索引同时存在时，mysql不管代价，优先选择使用全文索引
6. ref_or_null：与ref方法类似，只是增加了null值的比较。实际用的不多。
7. unique_subquery：用于where中的in形式子查询，子查询返回不重复值唯一值
8. index_subquery：用于in形式子查询使用到了辅助索引或者in常数列表，子查询可能返回重复值，可以使用索引将子查询去重。
9. range：索引范围扫描，常见于使用>,<,is null,between ,in ,like等运算符的查询中。
10. index_merge：表示查询使用了两个以上的索引，最后取交集或者并集，常见and ，or的条件使用了不同的索引，官方排序这个在ref_or_null之后，但是实际上由于要读取所个索引，性能可能大部分时间都不如range
11. index：索引全表扫描，把索引从头到尾扫一遍，常见于使用索引列就可以处理不需要读取数据文件的查询、可以使用索引排序或者分组的查询。
12. all：这个就是全表扫描数据文件，然后再在server层进行过滤返回符合要求的记录。