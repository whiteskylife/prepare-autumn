# 事务特性

事务是一组sql语句的集合。

- 只有使用了Innodb的数据库才能使用事务。
- 一个事务中的sql语句要么全部执行，要么全部不执行，这样可以保证数据库的完整性。

## ACID

事务具有四个特性：原子性、一致性、隔离性、持久性

1. 原子性(Atomicity)：一个事务中的所有sql语句，要么全部执行、要么全部都不执行。不会停止在其中的某一个环节。一旦发生错误，将会回滚事务中任何的语句都没有执行的状态。
2. 一致性(Consistency)：在事务执行的时候，会按照预设的规则
3. 隔离性(Isolation)：允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行是由于交叉执行而导致数据的不一致。
4. 持久性(Durability)：事务处理之后，对数据的修改是永久性的，即使关机重启也不会丢失。

*如果不使用start transaction 语句来开始一个事务，每一个语句都会自动提交。*

# 事务控制语句

- 开启事务：begin 、start transaction，开启一个事务。
- 提交事务：commit 、 commit work，执行这个事务
- 回滚事务：rollback 、rollback work，回滚这个事务。
- 建立保留点：savepoint savepoint_name，在事务中创建一个保留点。
- 删除保留点：release savepoint savepoint_name，删除一个保留点。
- 回滚保留点：rollback to savepoint_name，回滚到指定的保留点。
- 设置事务的隔离级别：set session transaction isolation level 这个级别有
  - read uncommitted(读取未提交)： 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读
  - read committed(读取已提交): 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生
  - repeatable read(可重读): 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。
  - serializable(可串行化): 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。但是性能很低，可能导致大量的

使用了begin和commit的事务示例：

```sql
-- 这是一个空表
mysql> select * from tableTest;
Empty set (0.00 sec)

mysql> begin;				--开启事务
Query OK, 0 rows affected (0.00 sec)

--添加三条事务语句
mysql> insert into tableTest values('20190501','laodongjie');
Query OK, 1 row affected (0.00 sec)

mysql> insert into tableTest values('20190701','wodeshengri');
Query OK, 1 row affected (0.00 sec)

mysql> insert into tableTest values('20190902','laopodeshengri');
Query OK, 1 row affected (0.00 sec)

--提交事务
mysql> commit;
Query OK, 0 rows affected (0.00 sec)

--查看事务执行之后的情况
mysql> select * from tableTest;
+------------+----------------+
| col_1      | col_2          |
+------------+----------------+
| 2019-05-01 | laodongjie     |
| 2019-07-01 | wodeshengri    |
| 2019-09-02 | laopodeshengri |
+------------+----------------+
3 rows in set (0.00 sec)
```

使用了begin和rollback的示例：

```sql
mysql> begin;
Query OK, 0 rows affected (0.00 sec)

mysql> insert into tableTest values('20190809','qixi');
Query OK, 1 row affected (0.00 sec)

-- 回滚了，所以上面的语句没有执行。
mysql> rollback;
Query OK, 0 rows affected (0.00 sec)

mysql> select * from tableTest;
+------------+----------------+
| col_1      | col_2          |
+------------+----------------+
| 2019-05-01 | laodongjie     |
| 2019-07-01 | wodeshengri    |
| 2019-09-02 | laopodeshengri |
+------------+----------------+
3 rows in set (0.00 sec)

-- 经过后续的测试，发现即使语句执行到这里，这个事务的安排依旧没有结束
-- 下一个事务开始的begin的时候，一个没有完成的事务即使commit，依旧会提交
```

回滚到某个点的示例：

```sql
-- 延续使用上面的建立的表
mysql> begin;
Query OK, 0 rows affected (0.00 sec)

-- 插入一个七夕节的日期的记录
mysql> insert into tableTest values('20190809','qixi');
Query OK, 1 row affected (0.00 sec)

-- 保存一个点名字为point
mysql> savepoint point;
Query OK, 0 rows affected (0.00 sec)

-- 再次插入一个中元节日期的记录
mysql> insert into tableTest values('20190815','zhongyuanjie');
Query OK, 1 row affected (0.00 sec)

-- 回滚到记录的点
mysql> rollback to point;
Query OK, 0 rows affected (0.00 sec)

-- 接着插入一个教师节的记录到表中
mysql> insert into tableTest values('20190910','jiaoshijie');
Query OK, 1 row affected (0.01 sec)

-- 提交、执行这个事务
mysql> commit;
Query OK, 0 rows affected (0.00 sec)

-- 查看这个事务的执行情况
mysql> select * from tableTest;
+------------+----------------+
| col_1      | col_2          |
+------------+----------------+
| 2019-05-01 | laodongjie     |
| 2019-07-01 | wodeshengri    |
| 2019-08-09 | qixi           |
| 2019-09-02 | laopodeshengri |
| 2019-09-10 | jiaoshijie     |
+------------+----------------+
5 rows in set (0.00 sec)
```

# 事务并发带来的问题

在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务（多个用户对统一数据进行操作）。并发虽然是必须的，但可能会导致以下的问题。

1. 脏读（Dirty read）: 
   - 事务A访问数据，进行修改，暂时还未提交。
   - 事务B访问这个数据，使用了这个数据是即将被事务A修改的数据。
   - 对于事务B而言，它获取的数据就是`脏数据`，这个过程就叫做`脏读`。
2. 丢失修改（Lost to modify）: 
   - 事务A在读取一个数据的时候，事务B也读了这个数据。
   - 事务A和事务B都对期望对这个数据进行修改，但是修改有先后性。
   - 如果A先对原始数据修改，那么事务B的修改必将覆盖事务A的修改之后的结果。
   - 那么首先对原始数据的修改必将丢失，这就叫做数据丢失。
3. 不可重复读（Unrepeatableread）: 
   - 事务A一开始，访问了一个数据。
   - 但是事务A还未结束的时候，事务B也访问，并且可能修改了原始数据。
   - 那么事务A再次访问这个数据的时候，那么两次的访问结果可能并不相同。
   - 这就发生了在一个事务内两次读到的数据是不一样的情况，称为不可重复读。
4. 幻读（Phantom read）: 
   - 事务A读取了一组数据。
   - 事务B在原始数据中插入了一些数据。
   - 事务A再次读取的时候，发生了两次读取的结果不一致的情况。

## 不可重复读和幻读

`不可重复读`异常产生原因是`update`和`delete`语句。

`幻读`异常产生的原因是`insert`语句。

# 锁

## 锁粒度

mysql提供了两种锁的粒度

- 行级锁
- 表级锁

锁定的资源越少，消耗资源就越小。因为锁定的资源越少，发生锁竞争的可能越小，越是发生锁竞争，越会消耗资源。

加锁本身就是一个消耗资源的行为。获取锁、释放锁、检查锁的状态，都会消耗系统资源。

所以需要合理加锁。锁消耗的资源不能浪费，应当在合适的粒度，使用锁。既可以满足并发的需求，也能使用足够小的资源。并且在不需要使用锁的时候，不使用锁。

## 锁的类型

### 读写锁

- 排他锁 ( X锁 ) ：写锁，独享资源，其他事务不能读和写，也不能加任何锁。
- 共享锁 ( S锁 )：读锁，共享资源，可以和其余事务一起读，其他事务不能加X锁。

规定：

- 一个事务对数据对象 A 加了 X 锁，就可以对 A 进行读取和更新。加锁期间其它事务不能对 A 加任何锁。
- 一个事务对数据对象 A 加了 S 锁，其他事务依然可以对 A 进行读取操作，但是不能进行更新操作。加锁期间其它事务能对 A 加 S 锁，但是不能加 X 锁。

### 意向锁

使用意向锁（Intention Locks）可以更容易地支持多粒度封锁。

在存在行级锁和表级锁的情况下，事务想要对表加锁，就需要先检测是否有其它事务对表或表中的任意一行加了锁，那么就需要对表的每一行都检测一次，这是非常耗时的。

意向锁在原来的 X/S 锁之上引入了 IX/IS，**IX/IS 都是表锁，用来表示一个事务想要在表中的某个数据行上加 X 锁或 S 锁**。有以下四个规定：

- 一个事务在获得某个数据行对象的 S 锁之前，必须先获得表的 IS 锁或者更强的锁；
- 一个事务在获得某个数据行对象的 X 锁之前，必须先获得表的 IX 锁。
- 一个事务拥有了 IS 锁，那么必定拥有表中某一行的 S 锁。
- 一个事务拥有了 IX 锁，那么必定拥有表中某一行的 X 锁。

通过引入意向锁，事务想要对表加 X 锁，只需要先检测是否有其它事务对表加了 IX  IS 锁，如果加了就表示有其它事务持有这个表中某一行的锁，因此事务加锁失败。这样就不用一行一行的检查加锁情况了，这样做的效率更高。

*当然，如果其他的事务持有这个表的表级S X锁，那么依旧加锁失败，但是和意向锁没有直接关系。*

各种锁的兼容关系如下 ( 这里的S和X都表示的是表锁 ) ：

*意向锁不会和行级的 X S锁相互排斥。*

|        |  IS  |  S   |  IX  |  X   |
| :----: | :--: | :--: | :--: | :--: |
| **IS** |  √   |  √   |  √   |  ×   |
| **S**  |  √   |  √   |  ×   |  ×   |
| **IX** |  √   |  ×   |  √   |  ×   |
| **X**  |  ×   |  ×   |  ×   |  ×   |

解释如下：

- 任意 IS/IX 锁之间都是兼容的，因为它们只是表示想要对表加锁，而不是真正加锁。
- S 锁只与 S 锁和 IS 锁兼容，也就是说事务 T 想要对数据行加 S 锁，其它事务可以已经获得对表或者表中的行的 S 锁。
- 意向排他锁 IX，其作用在于：通知数据库接下来需要施加什么锁并对表加锁。
  - 如果需要对记录A加排他锁，那么此时innodb引擎会先找到这张表。
  - 对该表加意向排他锁之后，再对记录A添加排他锁。
  - **事务持有表的意向排他锁，那么事务必然持有该表中某些数据行的排他锁。**
- 所以 IX 和 IX 不冲突是因为行中的排他锁是相互不冲突的，因为他们是行级锁。
- 上表中  X 和 X 冲突是因为，表中的 X 是表级锁。
- 所以一个事务拥有某表的IS锁，那么一定拥有其中某一行的S锁；一个事务拥有某表的IX锁，那么一定拥有其中某一行的X锁；但是 IS 和 IX 以及S X并不冲突（如果不在同一行的话）。 

## 封锁协议

- 一级封锁：修改数据的时候，必须加上 X 锁，修改结束释放 X 锁。
- 二级封锁：在一级的基础上，读取数据的时候，必须加上 S 锁，读取结束释放。
- 三级封锁：在二级的基础上，将释放 S 锁的时间推迟到读取事务结束。

### 一级封锁协议

事务对原始数据修改的时候，对数据加上X锁，直到修改数据完成之后再释放锁。这样就能保证事务对原始数据的修改不会`丢失`。因为在事务读取和修改的过程中，不会有其他的事务能够接近原始数据。

**解决了修改丢失的问题**。

*至于新的数据在后续的程序中将如何变化，和这段修改无关。至少在这个区间内，数据是正常被读取、修改的。*

### 二级封锁协议

**解决了脏读的问题**。

在一级封锁协议的基础上，在读取的时候，对数据加上 S 锁，在读取结束的时候释放。这样在读取的时候，就不可能同时存在有其他的事务在修改这个事务，因为根据一级封锁协议，修改数据需要加上 X 锁，但是在读取数据的时候需要加上 S 锁，由于 S 锁和 X 锁冲突，所以不可能存在在读取的时候，还存在事务对数据修改的情况。

### 三级封锁协议

**解决了不可重复读的问题**。

在二级封锁协议的基础上，将 S 锁释放的时间推迟到了，事务结束。这样保证了在事务读取的过程中，没有其他的事务可以修改这个数据。这样就保证了数据在读取期间发生改变。这就保证了数据在同一个事务里的读取的数据是一致的，这就保证了不可重复读的问题不会发生。

# 多版本并发控制

**多版本并发控制机制又叫做 : MVCC**

**MVCC无法解决幻读的问题。**

## 版本号

- 系统版本号：是一个递增的数字，每开始一个新的事务，系统版本号就会自动递增。
- 事务版本号：事务开始时的系统版本号。

## 隐藏的列

MVCC 在每行记录后面都保存着两个隐藏的列，用来存储这个行的两个版本号：

- 创建版本号：指示创建一个数据行的快照时的系统版本号；
- 删除版本号：如果该快照的删除版本号大于当前事务版本号表示该快照有效，否则表示该快照已经被删除了。

## undo日志

MVCC 使用到的快照存储在 Undo 日志中，该日志通过回滚指针把一个数据行的所有快照连接起来。

## 实现过程

开始一个事务时，事务的版本号大于所有行的创建版本号。这样才能保证在开启事务之后，没有别的事务对数据进行了修改。

- SELECT
  - 设读取某个数据行的事务为 T，T 要读取的数据行为 L 。
  - L的创建版本号必须小于T的版本号，表明数据行已存在。
  - L的删除版本号必须大于T的版本号，表明数据行还没被其他事务删除。
- INSERT
  - 当前的系统版本号作为创建版本号
- DELETE
  - 当前的系统版本号作为删除版本号
- UPDATE
  - 相当于先DELETE，再INSERT。

# Next-Key Locks

Next-Key Locks是MySql的InnoDB存储引擎的一种锁的实现，是用来解决幻的读的问题。

在可重复读的隔离级别下，配合MVCC使用可以解决幻读的问题。

## Record Locks

锁定一个记录上的索引，而不是记录本身。

如果表没有设置索引，InnoDB 会自动在主键上创建隐藏的聚簇索引，因此 Record Locks 依然可以使用。

## Gap Locks

锁定索引之间的间隙，但是不包含索引本身。例如当一个事务执行以下语句，其它事务就不能在 t.c 中插入 15。

```sql
SELECT c FROM t WHERE c BETWEEN 10 and 20 FOR UPDATE;
```

## Next-Key Locks

它是 Record Locks 和 Gap Locks 的结合，不仅锁定一个记录上的索引，也锁定索引之间的间隙。