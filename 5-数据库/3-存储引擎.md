# 索引的建立

```sql
mysql> desc tableTest;
+-------+------+------+-----+---------+-------+
| Field | Type | Null | Key | Default | Extra |
+-------+------+------+-----+---------+-------+
| col_1 | date | YES  |     | NULL    |       |
| col_2 | text | YES  |     | NULL    |       |
+-------+------+------+-----+---------+-------+
2 rows in set (0.01 sec)
```

## 单列索引

对于以上表，建立对于`col_1`的索引，语句是：

```sql
create index index_col_1 on tableTest(col_1);
```

```sql
alter table tableTest add index index_col_1(col_1);
```

在`tableTest(col_1)`中的列名`col_1`之后，可以加上长度量，如：

```sql
create index col_1_index on tableTest(col_1(10));
```

如果是char、varchar类型，length可以小于字段的实际长度，如果是BLOB和TEXT类型就必须指定长度。

## 唯一索引

唯一索引，与普通索引类似，但是不同的是唯一索引要求所有的类的值是唯一的，允许有空值。

```sql
create unique index index_col_1 on tableTest(col_1);
```

```sql
alter table tableTest add unique index index_col_1(col_1);
```

## 组合索引

一个表中含有多个索引不代表就是组合索引，通俗一点来讲，组合索引就是一个索引，包含了多个列。

创建一个组合索引的语句是：

```sql
create index indexName ON tableTest(col_1, col_2);
```

## 全文索引

文本字段上如果建立的是普通索引，那么只有对文本的字段内容前面的字符进行索引，其字符大小根据索引建立索引时申明的大小来规定。

用于在一篇文章中，检索文本信息。

```sql
alter table tableTest add fulltext index fullIndex(col2);
```

在添加了全文索引之后，就可以用SELECT查询命令去检索那些包含着一个或多个给定单词的数据记录了。

例如：

```sql
select * from tablename where match(col_1, col_2) against(‘aa′, ‘bb′);

```

将`col_1`和`col_2`添加全文索引之后，那么这个语句将会把`col_1`和`col_2`中的所有包含`aa`和`bb`的项列出来。

## 主键索引

```sql
alter table tableTest add primary key(col_1);
```

# 外键

如果一个字段 X 在表一中是主关键字，而在表二中不是主关键字，则字段 X 称为表二的外键。

## 外键的作用

- 级联删除：在删除主键表的时候，外键表同时删除
- 约束限制：当取值为No Action或者Restrict时，则当在主键表中删除对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除。（外键表约束主键表）
- Set Null：当取值为Set Null时，则当在主键表中删除对应记录时，首先检查该记录是否有对应外键，如果有则设置子表中该外键值为null。（一样是外键表约束主键表，不过这要求该外键允许取null）

## 外键的建立

```sql
ALTER TABLE '表名' ADD CONSTRAINT '外键名'
		FOREIGN KEY('外键字段') REFERENCES '关联表名'('关联字段'); --(去掉'')
```

`外键字段`与`关联字段`对应，并且在`关联表名`对应的表中应该是主键。



# 索引的删除

使用语句：

```sql
drop index indexName on tableName;
```

删除索引。

# 索引的优缺点

## 优点

- 单列索引：
  - 加快查询的速度。
- 唯一索引：
  - 加快查询速度。
  - 限制值的唯一性，可以为空。
- 全文索引：
  - 针对文本内容进行分词，加快查询速度。
- 组合索引
  - 多列组成的索引，效率高于单列索引的合并。
- 主键索引
  - 主键唯一性，加快查询速度，不能为空。

## 缺点

索引是占用空间的。

索引会影响update、insert、delete速度。

# 索引结构的分类

**索引是帮助mysql高效获取数据的数据结构。**

这是一个利用平衡搜索二叉树完成的一个索引的结构示意图。

![1](http://blog.codinglabs.org/uploads/pictures/theory-of-mysql-index/1.png)

大部分的数据库系统使用的都是`B Tree` 和`B+Tree` 。

## B-Tree

B-Tree：平衡多路查找树

![img](https:////upload-images.jianshu.io/upload_images/7361383-b4226ba0e306bd27.png?imageMogr2/auto-orient/)

​					这就是一个5阶B-Tree。

一个m阶的B-Tree

- 每个节点最多拥有m个子树
- 根节点至少有2个子树
- 分支节点至少拥有m/2颗子树（除根节点和叶子节点外都是分支节点）
- 所有叶子节点都在同一层、每个节点最多可以有m-1个key，并且以升序排列

## B+-Tree

B-Tree：有序数组+平衡多叉树
B+-Tree：有序数组链表+平衡多叉树

mysql最终选择的是B+树。

一个m阶的B+树的定义为：

- 除根节点外的内部节点，每个节点最多有m个关键字，最少有⌈m/2⌉个关键字。
  - 其中每个关键字对应一个子树；
  - 根节点要么没有子树，要么至少有2棵子树；
  - 所有的叶子节点包含了全部的关键字以及这些关键字指向文件的指针；
- 所有叶子节点中的关键字按大小顺序排列
- 相邻的叶子节点顺序链接（相当于是构成了一个顺序链表）
- 所有叶子节点在同一层
- 在内部节点上不包含信息



![](https://upload-images.jianshu.io/upload_images/5959612-40926cd74ad0bc6c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/598)

## B树和B+树的区别

- 关键字的数量不同
  - 在m阶的B树中，最多只用m-1个关键字。
  - 在m阶的B+树中，拥有m个关键字。
- 存储的位置不同
  - B树中，叶子结点和分支节点都存储数据信息。
  - B+树中，只有叶子结点存储数据信息。
- 分支节点的构造不同
  - B树中，存储关键字、关键字的数据信息和子节点的指针。
  - B+树中，存储关键字和存储子节点的指针。B+树的数据存储在叶子结点中。
- 查询方式不同
  - B树在找到具体的数值以后，则结束。
  - B+树则需要通过索引找到叶子结点中的数据才结束，也就是说B+树的搜索过程中走了一条从根结点到叶子结点的路径。

## B*树



![](https://upload-images.jianshu.io/upload_images/5959612-26c5a6e59af3ea4a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/586)

B*树是B+树的变体，在分支节点上，加上了指向兄弟节点的指针。

## 数据库的索引

B+树比B树更加适合做数据库的索引！

1. B+树的磁盘读写代价更低：
   - B+树的内部节点并没有指向关键字具体信息的指针，因此其内部节点相对B树更小，如果把所有同一内部节点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多，一次性读入内存的需要查找的关键字也就越多，相对IO读写次数就降低了。
2. B+树的查询效率更加稳定：
   - 由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。
3. 方便遍历：
   - 由于B+树的数据都存储在叶子结点中，分支结点均为索引，方便扫库，只需要扫一遍叶子结点即可，但是B树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫，所以B+树更加适合在区间查询的情况，所以通常B+树用于数据库索引。

B树在提高了IO性能的同时并没有解决元素遍历的我效率低下的问题，正是为了解决这个问题，B+树应用而生。B+树只需要去遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作或者说效率太低。

# 引擎

## 查询

查询表的信息，其中包括表的引擎信息。

```sql
show table status from Test where name = 'x';
```

## 建表

指定某种引擎建表。

```sql
create table x(
  userName varchar(8),
  Id int(11),
  schoolName varchar(11)
)ENGINE = MYISAM default CHARSET = gbk; 
```

## 对比

| 特点       | MyISAM | InnoDB | MEMORY | MERGE |
| ---------- | ------ | ------ | ------ | ----- |
| 存储显示   | 有     | 64TB   | 有     | 无    |
| 事务安全   |        | 支持   |        |       |
| 锁机制     | 表所   | 行锁   | 表所   | 表所  |
| B树索引    | 支持   | 支持   | 支持   | 支持  |
| 哈希索引   |        |        | 支持   |       |
| 全文索引   | 支持   |        |        |       |
| 集群索引   |        | 支持   |        |       |
| 数据缓存   |        | 支持   | 支持   |       |
| 索引缓存   | 支持   | 支持   | 支持   | 支持  |
| 数据可压缩 | 支持   |        |        |       |
| 空间使用   | 低     | 高     | N/A    | 低    |
| 内存使用   | 低     | 高     | 中等   | 低    |
| 批量插入   | 高     | 低     | 高     | 高    |
| 外键       |        | 支持   |        |       |

# MyISAM

它不支持事务，也不支持外键，尤其是访问速度快，对事务完整性没有要求或者**以SELECT、INSERT为主**的应用基本都可以使用这个引擎来创建表。
每个MyISAM在磁盘上存储成3个文件，其中文件名和表名都相同，但是扩展名分别为：

- .frm(存储表定义)
- MYD(MYData，存储数据)
- MYI(MYIndex，存储索引)

数据文件和索引文件可以放置在不同的目录，平均分配IO，获取更快的速度。要指定数据文件和索引文件的路径，需要在创建表的时候通过DATA DIRECTORY和INDEX DIRECTORY语句指定，文件路径需要使用绝对路径。
每个MyISAM表都有一个标志，服务器或myisamchk程序在检查MyISAM数据表时会对这个标志进行设置。MyISAM表还有一个标志用来表明该数据表在上次使用后是不是被正常的关闭了。如果服务器以为当机或崩溃，这个标志可以用来判断数据表是否需要检查和修复。如果想让这种检查自动进行，可以在启动服务器时使用--myisam-recover现象。这会让服务器在每次打开一个MyISAM数据表是自动检查数据表的标志并进行必要的修复处理。MyISAM类型的表可能会损坏，可以使用CHECK TABLE语句来检查MyISAM表的健康，并用REPAIR TABLE语句修复一个损坏到MyISAM表。

MyISAM的表还支持3种不同的存储格式：

- 静态(固定长度)表
- 动态表
- 压缩表

　　其中静态表是默认的存储格式。静态表中的字段都是非变长字段，这样每个记录都是固定长度的，这种存储方式的优点是存储非常迅速，容易缓存，出现故障容易恢复；缺点是占用的空间通常比动态表多。静态表在数据存储时会根据列定义的宽度定义补足空格，但是在访问的时候并不会得到这些空格，这些空格在返回给应用之前已经去掉。同时需要注意：在某些情况下可能需要返回字段后的空格，而使用这种格式时后面到空格会被自动处理掉。
　　动态表包含变长字段，记录不是固定长度的，这样存储的优点是占用空间较少，但是频繁到更新删除记录会产生碎片，需要定期执行OPTIMIZE TABLE语句或myisamchk -r命令来改善性能，并且出现故障的时候恢复相对比较困难。
　　压缩表由myisamchk工具创建，占据非常小的空间，因为每条记录都是被单独压缩的，所以只有非常小的访问开支。 

# InnoDB

InnoDB是一个健壮的事务型存储引擎，这种存储引擎已经被很多互联网公司使用，为用户操作非常大的数据存储提供了一个强大的解决方案。我的电脑上安装的MySQL 5.6.13版，InnoDB就是作为默认的存储引擎。InnoDB还引入了行级锁定和外键约束，在以下场合下，使用InnoDB是最理想的选择：

1.更新密集的表。InnoDB存储引擎特别适合处理多重并发的更新请求。
2.事务。InnoDB存储引擎是支持事务的标准MySQL存储引擎。
3.自动灾难恢复。与其它存储引擎不同，InnoDB表能够自动从灾难中恢复。
4.外键约束。MySQL支持外键的存储引擎只有InnoDB。
5.支持自动增加列AUTO_INCREMENT属性。

一般来说，如果需要事务支持，并且有较高的并发读取频率，InnoDB是不错的选择。

# MEMORY

使用MySQL Memory存储引擎的出发点是速度。为得到最快的响应时间，采用的逻辑存储介质是系统内存。虽然在内存中存储表数据确实会提供很高的性能，但当mysqld守护进程崩溃时，所有的Memory数据都会丢失。获得速度的同时也带来了一些缺陷。它要求存储在Memory数据表里的数据使用的是长度不变的格式，这意味着不能使用BLOB和TEXT这样的长度可变的数据类型，VARCHAR是一种长度可变的类型，但因为它在MySQL内部当做长度固定不变的CHAR类型，所以可以使用。

一般在以下几种情况下使用Memory存储引擎：

1.目标数据较小，而且被非常频繁地访问。在内存中存放数据，所以会造成内存的使用，可以通过参数max_heap_table_size控制Memory表的大小，设置此参数，就可以限制Memory表的最大大小。

2.如果数据是临时的，而且要求必须立即可用，那么就可以存放在内存表中。

3.存储在Memory表中的数据如果突然丢失，不会对应用服务产生实质的负面影响。

Memory同时支持散列索引和B树索引。B树索引的优于散列索引的是，可以使用部分查询和通配查询，也可以使用<、>和>=等操作符方便数据挖掘。散列索引进行“相等比较”非常快，但是对“范围比较”的速度就慢多了，因此散列索引值适合使用在=和<>的操作符中，不适合在<或>操作符中，也同样不适合用在order by子句中。

# MERGE

MERGE存储引擎是一组MyISAM表的组合，这些MyISAM表结构必须完全相同，尽管其使用不如其它引擎突出，但是在某些情况下非常有用。说白了，Merge表就是几个相同MyISAM表的聚合器；Merge表中并没有数据，对Merge类型的表可以进行查询、更新、删除操作，这些操作实际上是对内部的MyISAM表进行操作。Merge存储引擎的使用场景。

对于服务器日志这种信息，一般常用的存储策略是将数据分成很多表，每个名称与特定的时间端相关。例如：可以用12个相同的表来存储服务器日志数据，每个表用对应各个月份的名字来命名。当有必要基于所有12个日志表的数据来生成报表，这意味着需要编写并更新多表查询，以反映这些表中的信息。与其编写这些可能出现错误的查询，不如将这些表合并起来使用一条查询，之后再删除Merge表，而不影响原来的数据，删除Merge表只是删除Merge表的定义，对内部的表没有任何影响。